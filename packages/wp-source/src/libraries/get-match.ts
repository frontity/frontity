import { Pattern } from "../../types";
import pathToRegexp, { Key } from "path-to-regexp";

/**
 * Extract the parameters of the `path-to-regexp` pattern from the link.
 *
 * @param link - The link that was matched.
 * @param regexp - The regexp from `path-to-regexp` that will be used.
 * @param keys - The array with keys generated by `path-to-regexp`.
 *
 * @returns An object with the parameter names and its corresponding values
 * from the link.
 */
const extractParameters = (
  link: string,
  regexp: RegExp,
  keys: Key[]
): Record<string, string> =>
  link
    // First remove the query and hash part.
    // These parameters are extracted from the pathname.
    .replace(/\?.*/, "")
    .match(regexp)
    .slice(1)
    .reduce((result, value, index) => {
      result[keys[index].name] = value;
      return result;
    }, {});

/**
 * The return object for the {@link getMatch} function.
 */
interface GetMatchReturn<Patt extends Pattern> {
  /**
   * The params extracted from the `path-to-regexp` pattern or the named capture
   * groups of the regular expresion.
   */
  params: Record<string, string>;

  /**
   * The handler/redirection function that was matched.
   */
  func: Patt["func"];

  /**
   * The name of the handler/redirection function that was matched.
   */
  name: string;

  /**
   * The pattern of the handler/redirection function that was matched.
   */
  pattern: string;
}

/**
 * Match a link with a list of handler/redirection objects.
 *
 * @param link - The link to be matched.
 * @param list - The list of handler/redirection objects.
 *
 * @returns An object containing the matched handler/redirection. Defined in
 * {@link GetMatchReturn}.
 */
export const getMatch = <Patt extends Pattern>(
  link: string,
  list: Patt[]
): GetMatchReturn<Patt> | null => {
  const result = list
    .sort(({ priority: p1 }, { priority: p2 }) => p1 - p2)
    .map(({ name, priority, pattern, func }) => {
      const keys = [];
      const regexp = pattern.startsWith("RegExp:")
        ? new RegExp(pattern.replace("RegExp:", ""))
        : pathToRegexp(pattern, keys, { endsWith: "?" });
      return { name, priority, pattern, regexp, keys, func };
    })
    .find(({ regexp }) => regexp.test(link));

  if (result) {
    try {
      return {
        func: result.func,
        params: result.pattern.startsWith("RegExp:")
          ? result.regexp.exec(link).groups
          : extractParameters(link, result.regexp, result.keys),
        name: result.name,
        pattern: result.pattern,
      }

    } catch {
      return null;
    }
  } else {
    return null;
  }
};
